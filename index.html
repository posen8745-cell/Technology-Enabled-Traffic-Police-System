<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tå­—è·¯å£ï½œç§‘æŠ€äº¤è­¦ç‰ˆï¼‹è‡ªå‹•èªéŸ³ï¼‹JSONå¡è»ŠåŠ‡æœ¬ï¼ˆå®Œæ•´ç‰ˆï¼‰</title>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#121a2b;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --good:#3cff7a;
      --bad:#ff3b3b;
      --warn:#ffd43b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system,
                   "Segoe UI", Roboto, "Noto Sans TC", Arial;
      background:
        radial-gradient(1200px 800px at 30% 20%,
          #18234a 0%, var(--bg) 55%, #060a14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
    }
    .wrap{
      width:min(1320px, 100%);
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 1fr 460px;
      gap:16px;
      align-items:start;
    }
    .card{
      background:
        linear-gradient(180deg,
          rgba(255,255,255,0.06),
          rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      overflow:hidden;
    }
    .canvasWrap{ padding:12px; }
    canvas{
      width:100%;
      height:680px;
      display:block;
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .panel{ padding:14px; background: rgba(0,0,0,0.12); }
    h1{
      font-size:15px;
      margin:0 0 10px 0;
      letter-spacing:.4px;
      line-height:1.35;
    }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      color: var(--muted);
      margin-bottom:8px;
    }
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot.green{background:var(--good)}
    .dot.red{background:var(--bad)}
    .dot.yellow{background:var(--warn)}
    .divider{
      height:1px;
      background: rgba(255,255,255,0.10);
      margin: 12px 0;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin:10px 0;
    }
    label{ font-size: 13px; color: var(--muted); }
    input[type="number"], select, textarea{
      width: 190px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
    textarea{
      width:100%;
      height:160px;
      font-family: ui-monospace, SFMono-Regular, Menlo,
                   Monaco, Consolas, "Courier New", monospace;
      font-size:12px;
    }
    .btns{ display:flex; gap:10px; margin-top:12px; }
    button{
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background:
        linear-gradient(180deg,
          rgba(255,255,255,0.10),
          rgba(255,255,255,0.03));
      color: var(--text);
      cursor:pointer;
      font-weight: 600;
    }
    button:hover{filter:brightness(1.08)}
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
      filter:none
    }
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin: 8px 0;
      font-size: 13px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular,
                   Menlo, Monaco, Consolas,
                   "Courier New", monospace;
    }
    .tiny{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.5;
    }
    .subcard{
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,0.16);
      margin-top: 10px;
    }
    .checkrow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 6px 0;
    }
    input[type="checkbox"]{ transform: scale(1.1); }
  </style>
</head>

<body>
  <div class="wrap">

    <!-- ===== å·¦å´ç•«å¸ƒ ===== -->
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <!-- ===== å³å´æ§åˆ¶é¢æ¿ ===== -->
    <div class="card panel">
      <h1>
        ğŸš¦ ç§‘æŠ€äº¤è­¦æ¨¡æ“¬ç³»çµ±ï¼ˆå®Œæ•´ç‰ˆï¼‰<br/>
        ğŸ”Š è‡ªå‹•èªéŸ³è§¸ç™¼ï¼‹ğŸ§© JSON å¡è»ŠåŠ‡æœ¬
      </h1>

      <div class="pill">
        <span class="dot green" id="phaseDot"></span>
        <span id="phaseText">Phaseï¼š--</span>
      </div>

      <div class="divider"></div>

      <!-- ===== åŸºæœ¬è»Šæµ ===== -->
      <div class="row">
        <label>è»Šæµç”Ÿæˆç‡ï¼ˆ0~1ï¼‰</label>
        <input type="number" id="spawn" min="0" max="1" step="0.05" value="0.20" />
      </div>

      <!-- ===== èªéŸ³è¨­å®š ===== -->
      <div class="subcard">
        <div class="tiny"><b>ğŸ”Š è‡ªå‹•èªéŸ³æé†’ï¼ˆå›å µè§¸ç™¼ï¼‰</b></div>

        <div class="checkrow">
          <label>å•Ÿç”¨èªéŸ³</label>
          <input type="checkbox" id="voiceOn" checked />
        </div>

        <div class="row">
          <label>è§¸ç™¼é–€æª»ï¼ˆpxï¼‰</label>
          <input type="number" id="voicePx" min="10" max="400" value="120" />
        </div>

        <div class="row">
          <label>å†·å»ç§’æ•¸</label>
          <input type="number" id="voiceCd" min="2" max="120" value="12" />
        </div>

        <div class="row">
          <label>èªéŸ³æ¨¡å¼</label>
          <select id="voicePreset">
            <option value="std">æ¨™æº–ç‰ˆ</option>
            <option value="strong">å¼·åŒ–ç‰ˆ</option>
            <option value="cop">äº¤è­¦å•Ÿå‹•ç‰ˆ</option>
            <option value="short">è¶…çŸ­æ’æ’­</option>
          </select>
        </div>

        <div class="btns">
          <button id="voiceTest">æ¸¬è©¦æ’­å ±</button>
          <button id="voiceStop">åœæ­¢</button>
        </div>
      </div>

      <!-- ===== JSON åŠ‡æœ¬ ===== -->
      <div class="subcard">
        <div class="tiny"><b>ğŸ§© JSON å¡è»ŠåŠ‡æœ¬</b></div>

        <textarea id="scenarioJson" placeholder='{
  "name": "å°–å³°æ¸¬è©¦",
  "events": [
    { "at": 0,   "set": { "spawn": 0.2 } },
    { "at": 60,  "set": { "spawn": 0.6 } },
    { "at": 120, "set": { "spawn": 0.8 } }
  ]
}'></textarea>

        <div class="btns">
          <button id="loadScenario">è¼‰å…¥åŠ‡æœ¬</button>
          <button id="clearScenario">æ¸…ç©º</button>
        </div>

        <div class="tiny" id="scenarioHint">å°šæœªè¼‰å…¥</div>
      </div>
      <!-- ===== å³å´ç‹€æ…‹é¡¯ç¤º ===== -->
      <div class="divider"></div>

      <div class="kv"><div>ä¸»ç·š1 è»Šç‡ˆ</div><div class="mono" id="sigM1">--</div></div>
      <div class="kv"><div>ä¸»ç·š2 å·¦è½‰ç‡ˆ</div><div class="mono" id="sigM2L">--</div></div>
      <div class="kv"><div>ä¸»ç·š2 å³è½‰ç‡ˆ</div><div class="mono" id="sigM2R">--</div></div>
      <div class="kv"><div>è¡Œäººç‹€æ…‹</div><div class="mono" id="sigPed">--</div></div>
      <div class="kv"><div>æœ¬ç›¸ä½å‰©é¤˜ç§’</div><div class="mono" id="count">--</div></div>
      <div class="kv"><div>æ’éšŠ(ä¼°)</div><div class="mono" id="qText">--</div></div>
      <div class="kv"><div>ç§‘æŠ€äº¤è­¦</div><div class="mono" id="copText">--</div></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const $ = (id) => document.getElementById(id);

  // =======================
  // UI ç¶å®š
  // =======================
  const ui = {
    spawn: $('spawn'),

    voiceOn: $('voiceOn'),
    voicePx: $('voicePx'),
    voiceCd: $('voiceCd'),
    voicePreset: $('voicePreset'),
    voiceTest: $('voiceTest'),
    voiceStop: $('voiceStop'),

    scenarioJson: $('scenarioJson'),
    loadScenario: $('loadScenario'),
    clearScenario: $('clearScenario'),
    scenarioHint: $('scenarioHint'),

    phaseDot: $('phaseDot'),
    phaseText: $('phaseText'),

    sigM1: $('sigM1'),
    sigM2L: $('sigM2L'),
    sigM2R: $('sigM2R'),
    sigPed: $('sigPed'),
    count: $('count'),
    qText: $('qText'),
    copText: $('copText'),
  };

  // =======================
  // åŸºæœ¬å¸¸æ•¸
  // =======================
  const SIG = { RED:'RED', YELLOW:'YELLOW', GREEN:'GREEN' };

  let simSec = 0;
  let running = true;

  // =======================
  // ğŸ”Š èªéŸ³æ¨¡çµ„
  // =======================
  const VOICE_PRESETS = {
    std:   'å‰æ–¹è·¯å£è»Šæµå£…å¡ï¼Œè«‹ä¾è™ŸèªŒè¡Œé§›ï¼Œå‹¿é—–ç´…ç‡ˆã€‚æœ¬è·¯å£å·²å•Ÿç”¨ç§‘æŠ€åŸ·æ³•ï¼Œè«‹ç”¨è·¯äººé…åˆï¼Œè¬è¬ã€‚',
    strong:'ç›®å‰è·¯å£åš´é‡å£…å¡ï¼Œè«‹å„ä½é§•é§›å‹™å¿…éµå®ˆç´…ç¶ ç‡ˆè™ŸèªŒï¼Œåˆ‡å‹¿æ¶å¿«é€šè¡Œã€‚æœ¬è·¯å£å·²å¯¦æ–½ç§‘æŠ€åŸ·æ³•ï¼Œé•è¦å°‡ä¾æ³•å–ç· ã€‚',
    cop:   'è«‹æ³¨æ„ï¼Œå‰æ–¹è·¯å£å·²å•Ÿå‹•ç§‘æŠ€äº¤è­¦ç³»çµ±ï¼Œè«‹éµå®ˆè™ŸèªŒè¡Œé§›ï¼Œç´…ç‡ˆè«‹åœï¼Œé•è¦å°‡è‡ªå‹•å–ç· ã€‚',
    short: 'è«‹éµå®ˆè™ŸèªŒï¼Œç´…ç‡ˆè«‹åœï¼Œè·¯å£å·²å•Ÿç”¨ç§‘æŠ€åŸ·æ³•ã€‚'
  };

  let voiceCooldownUntil = 0;

  function speak(text){
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'zh-TW';
    u.rate = 0.95;
    u.volume = 1.0;
    window.speechSynthesis.speak(u);
  }

  function stopSpeak(){
    if (!('speechSynthesis' in window)) return;
    window.speechSynthesis.cancel();
  }

  function voiceMaybeTrigger(spWorst){
    if (!ui.voiceOn?.checked) return;
    if (!spWorst) return;

    const pxTh = Number(ui.voicePx?.value ?? 120);
    const cd   = Number(ui.voiceCd?.value ?? 12);
    if (simSec < voiceCooldownUntil) return;

    if (spWorst.severityPx < pxTh){
      const key = ui.voicePreset?.value ?? 'std';
      speak(VOICE_PRESETS[key] || VOICE_PRESETS.std);
      voiceCooldownUntil = simSec + Math.max(2, cd);
    }
  }

  ui.voiceTest?.addEventListener('click', () => {
    const key = ui.voicePreset?.value ?? 'std';
    speak(VOICE_PRESETS[key] || VOICE_PRESETS.std);
  });

  ui.voiceStop?.addEventListener('click', stopSpeak);

  // =======================
  // ğŸ§© JSON å¡è»ŠåŠ‡æœ¬
  // =======================
  const APPLY_MAP = {
    spawn: 'spawn'
  };

  let scenario = null;
  let scenarioIdx = 0;

  function applyScenarioSet(setObj){
    if (!setObj) return;
    for (const [k,v] of Object.entries(setObj)){
      const uiKey = APPLY_MAP[k];
      if (!uiKey || !ui[uiKey]) continue;
      ui[uiKey].value = String(v);
    }
  }

  function loadScenarioFromText(txt){
    let obj;
    try{
      obj = JSON.parse(txt);
    }catch(e){
      ui.scenarioHint.textContent = 'âŒ JSON è§£æå¤±æ•—';
      return;
    }
    if (!Array.isArray(obj.events)){
      ui.scenarioHint.textContent = 'âŒ éœ€è¦ events';
      return;
    }
    obj.events = obj.events
      .map(e => ({ at:Number(e.at||0), set:e.set||{} }))
      .sort((a,b)=>a.at-b.at);

    scenario = obj;
    scenarioIdx = 0;
    ui.scenarioHint.textContent = `âœ… å·²è¼‰å…¥ ${obj.name||''}`;
  }

  function scenarioTick(){
    if (!scenario) return;
    while (scenarioIdx < scenario.events.length &&
           simSec >= scenario.events[scenarioIdx].at){
      applyScenarioSet(scenario.events[scenarioIdx].set);
      scenarioIdx++;
    }
  }

  ui.loadScenario?.addEventListener('click', () => {
    loadScenarioFromText(ui.scenarioJson.value || '');
  });

  ui.clearScenario?.addEventListener('click', () => {
    scenario = null;
    scenarioIdx = 0;
    ui.scenarioHint.textContent = 'å°šæœªè¼‰å…¥';
  });

  // =======================
  // ç•«å¸ƒå°ºå¯¸èˆ‡å¹¾ä½•
  // =======================
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function geom(){
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    const road = {
      y: Math.round(H*0.38),
      h: 150,
      x: Math.round(W*0.52),
      w: 240
    };

    const inter = {
      x0: road.x-road.w/2,
      x1: road.x+road.w/2,
      y0: road.y-road.h/2,
      y1: road.y+road.h/2
    };

    return { W, H, road, inter };
  }

  // =======================
  // å›å µï¼ˆSpillbackï¼‰åµæ¸¬
  // =======================
  function spillbackStatus(g){
    // ç°¡åŒ–ç‰ˆæœ¬ï¼šå¯¦éš›å®Œæ•´ç‰ˆæœƒä¾è»Šå°¾è·é›¢ç®— severityPx
    // é€™è£¡ä¿ç•™ä»‹é¢ï¼Œä¾›èªéŸ³ / ç§‘æŠ€äº¤è­¦å…±ç”¨
    const fake = Math.random()*300;
    if (fake < 200){
      return {
        worst: {
          severityPx: fake,
          key: 'M1S',
          reason: 'ç¤ºæ„å›å µ'
        }
      };
    }
    return { worst:null };
  }

  // =======================
  // ç›¸ä½ï¼ˆç°¡åŒ–ï¼‰
  // =======================
  let phase = 'M1';
  let remaining = 20;

  function tick1s(){
    simSec += 1;
    remaining -= 1;

    // ğŸ§© JSON åŠ‡æœ¬
    scenarioTick();

    // ğŸ”Š èªéŸ³ï¼ˆç§‘æŠ€äº¤è­¦å›å µï¼‰
    const g0 = geom();
    const sp0 = spillbackStatus(g0);
    voiceMaybeTrigger(sp0.worst);

    if (remaining <= 0){
      phase = phase === 'M1' ? 'M2' : 'M1';
      remaining = 20;
    }
  }

  // =======================
  // ç¹ªåœ–ï¼ˆç°¡åŒ–ï¼‰
  // =======================
  function draw(){
    resizeCanvas();
    const g = geom();
    ctx.clearRect(0,0,g.W,g.H);

    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(0, g.road.y-g.road.h/2, g.W, g.road.h);

    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    ctx.fillStyle = '#fff';
    ctx.fillText(`Phase: ${phase}`, 20, 20);
    ctx.fillText(`Remain: ${remaining}`, 20, 40);
  }

  // =======================
  // ä¸»å¾ªç’°
  // =======================
  setInterval(tick1s, 1000);

  function loop(){
    draw();
    requestAnimationFrame(loop);
  }

  resizeCanvas();
  loop();

})();
</script>

</body>
</html>
  // =======================
  // ğŸš— è»Šè¼›è³‡æ–™çµæ§‹
  // =======================
  const cars = [];
  const CAR_W = 22;
  const CAR_H = 14;

  function rnd(a,b){ return a + Math.random()*(b-a); }

  // =======================
  // åœæ­¢ç·šåˆ¤æ–·
  // =======================
  function stopLine(car, g){
    if (car.kind === 'M1L') return g.inter.x0 - 22;
    if (car.kind === 'M1R') return g.inter.x1 + 22;
    if (car.kind === 'M2')  return g.inter.y1 + 22;
    return 0;
  }

  function pastStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x > s;
    if (car.kind === 'M1R') return car.x < s;
    if (car.kind === 'M2')  return car.y < s;
    return false;
  }

  function approachingStop(car, g){
    const s = stopLine(car, g);
    if (car.kind === 'M1L') return car.x + car.w/2 >= s;
    if (car.kind === 'M1R') return car.x - car.w/2 <= s;
    if (car.kind === 'M2')  return car.y - car.h/2 <= s;
    return false;
  }

  // =======================
  // ğŸš¦ è™ŸèªŒå…è¨±åˆ¤æ–·
  // =======================
  function allowedBySignal(car){
    if (phase === 'M1'){
      return car.kind === 'M1L' || car.kind === 'M1R';
    }
    if (phase === 'M2'){
      return car.kind === 'M2';
    }
    return false;
  }

  // =======================
  // ğŸš˜ ç”Ÿæˆè»Šè¼›
  // =======================
  function spawnCar(g){
    const p = Number(ui.spawn.value);
    if (Math.random() > p) return;

    const sp = rnd(90, 140);
    const r = Math.random();

    if (r < 0.4){
      cars.push({
        kind:'M1L',
        x:-60,
        y:g.road.y+20,
        vx:sp, vy:0,
        w:CAR_W, h:CAR_H
      });
    } else if (r < 0.8){
      cars.push({
        kind:'M1R',
        x:g.W+60,
        y:g.road.y-20,
        vx:-sp, vy:0,
        w:CAR_W, h:CAR_H
      });
    } else {
      cars.push({
        kind:'M2',
        x:g.road.x,
        y:g.H+60,
        vx:0, vy:-sp,
        w:CAR_H, h:CAR_W
      });
    }
  }

  // =======================
  // ğŸš— è·Ÿè»Šèˆ‡åœæ­¢
  // =======================
  const SAFE_GAP = 10;

  function updateCars(dt, g){
    // åœæ­¢ç·š
    for (const car of cars){
      car.needStop =
        approachingStop(car, g) &&
        !pastStop(car, g) &&
        !allowedBySignal(car);
    }

    // è·Ÿè»Š
    const lanes = {};
    for (const car of cars){
      const key = car.kind;
      if (!lanes[key]) lanes[key] = [];
      lanes[key].push(car);
    }

    for (const arr of Object.values(lanes)){
      arr.sort((a,b)=>{
        if (a.kind === 'M1L') return b.x - a.x;
        if (a.kind === 'M1R') return a.x - b.x;
        if (a.kind === 'M2')  return a.y - b.y;
        return 0;
      });

      for (let i=1;i<arr.length;i++){
        const lead = arr[i-1];
        const foll = arr[i];
        const gap =
          (lead.kind==='M2'
            ? (lead.y - lead.h/2) - (foll.y + foll.h/2)
            : Math.abs(lead.x - foll.x) - lead.w);
        if (gap < SAFE_GAP) foll.needStop = true;
      }
    }

    // æ›´æ–°ä½ç½®
    for (const car of cars){
      if (!car.needStop){
        car.x += car.vx * dt;
        car.y += car.vy * dt;
      }
    }

    // æ¸…é™¤é›¢å ´
    for (let i=cars.length-1;i>=0;i--){
      const c = cars[i];
      if (c.x < -200 || c.x > g.W+200 ||
          c.y < -200 || c.y > g.H+200){
        cars.splice(i,1);
      }
    }
  }

  // =======================
  // ğŸ“ æ’éšŠé•·åº¦ï¼ˆå›å µï¼‰
  // =======================
  function measureQueues(g){
    let qM1 = 0, qM2 = 0;

    for (const c of cars){
      if (pastStop(c, g)) continue;
      if (c.kind === 'M1L' || c.kind === 'M1R'){
        if (Math.abs(c.x - stopLine(c,g)) < 260) qM1++;
      }
      if (c.kind === 'M2'){
        if (Math.abs(c.y - stopLine(c,g)) < 260) qM2++;
      }
    }
    return { qM1, qM2 };
  }

  // =======================
  // ğŸ‘® ç§‘æŠ€äº¤è­¦ï¼ˆcopï¼‰
  // =======================
  const COP = {
    ENABLED: true,
    SPILLBACK_PX: 120
  };

  function copDecide(g){
    if (!COP.ENABLED) return null;
    const q = measureQueues(g);

    if (q.qM1 > 6){
      return { key:'M1', reason:'ä¸»ç·šå›å µ' };
    }
    if (q.qM2 > 6){
      return { key:'M2', reason:'ä¸‹æ¸¸å›å µ' };
    }
    return null;
  }

  // =======================
  // â± ç›¸ä½æ§åˆ¶ï¼ˆå«ç§‘æŠ€äº¤è­¦ï¼‰
  // =======================
  function tick1s(){
    simSec += 1;
    remaining -= 1;

    // ğŸ§© JSON åŠ‡æœ¬
    scenarioTick();

    // ğŸ‘® ç§‘æŠ€äº¤è­¦ï¼‹ğŸ”Š èªéŸ³
    const g = geom();
    const decision = copDecide(g);
    if (decision){
      ui.copText.textContent = `ä»‹å…¥ï¼š${decision.reason}`;
      voiceMaybeTrigger({ severityPx: 0 });
      phase = decision.key;
      remaining = 25;
      return;
    }

    if (remaining <= 0){
      phase = phase === 'M1' ? 'M2' : 'M1';
      remaining = 20;
    }
  }

  // =======================
  // ğŸ¨ ç•«è»Š
  // =======================
  function drawCars(){
    for (const car of cars){
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.fillStyle =
        car.kind === 'M2'
          ? 'rgba(170,160,255,0.9)'
          : 'rgba(120,200,255,0.9)';
      ctx.fillRect(-car.w/2,-car.h/2,car.w,car.h);
      ctx.restore();
    }
  }
  // =======================
  // ğŸ–¼ ç¹ªè£½è·¯å£
  // =======================
  function drawRoad(g){
    ctx.clearRect(0,0,g.W,g.H);

    // æ©«å‘ä¸»ç·š
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(0, g.road.y-g.road.h/2, g.W, g.road.h);

    // ç¸±å‘æ”¯ç·š
    ctx.fillRect(g.road.x-g.road.w/2, g.road.y, g.road.w, g.H-g.road.y);

    // åœæ­¢ç·š
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 3;

    // M1 å·¦ä¾†
    ctx.beginPath();
    ctx.moveTo(g.inter.x0-22, g.road.y-g.road.h/2+6);
    ctx.lineTo(g.inter.x0-22, g.road.y+g.road.h/2-6);
    ctx.stroke();

    // M1 å³ä¾†
    ctx.beginPath();
    ctx.moveTo(g.inter.x1+22, g.road.y-g.road.h/2+6);
    ctx.lineTo(g.inter.x1+22, g.road.y+g.road.h/2-6);
    ctx.stroke();

    // M2 ä¸‹ä¾†
    ctx.beginPath();
    ctx.moveTo(g.road.x-g.road.w/2+6, g.inter.y1+22);
    ctx.lineTo(g.road.x+g.road.w/2-6, g.inter.y1+22);
    ctx.stroke();
  }

  // =======================
  // ğŸš¦ ç¹ªè£½è™ŸèªŒç‹€æ…‹
  // =======================
  function drawSignals(){
    ctx.fillStyle = '#fff';
    ctx.font = '12px ui-monospace, Menlo, Consolas';

    ctx.fillText(`Phase: ${phase}`, 20, 20);
    ctx.fillText(`Remain: ${remaining}s`, 20, 36);
    ctx.fillText(`Time: ${simSec}s`, 20, 52);
  }

  // =======================
  // ğŸ”„ ä¸»å‹•ç•«å¾ªç’°
  // =======================
  let last = performance.now();
  let acc = 0;
  let spawnAcc = 0;

  function frame(now){
    resizeCanvas();
    const g = geom();

    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    acc += dt;
    while (acc >= 1){
      acc -= 1;
      tick1s();
    }

    spawnAcc += dt;
    while (spawnAcc >= 1){
      spawnAcc -= 1;
      spawnCar(g);
    }

    updateCars(dt, g);

    drawRoad(g);
    drawCars();
    drawSignals();

    // UI åŒæ­¥
    ui.phaseText.textContent = `Phaseï¼š${phase}`;
    ui.count.textContent = remaining;

    const q = measureQueues(g);
    ui.qText.textContent = `M1:${q.qM1} M2:${q.qM2}`;

    requestAnimationFrame(frame);
  }

  // =======================
  // â–¶ åˆå§‹åŒ–
  // =======================
  function init(){
    resizeCanvas();
    simSec = 0;
    phase = 'M1';
    remaining = 20;
    cars.length = 0;
    scenario = null;
    scenarioIdx = 0;
    ui.copText.textContent = 'å¾…å‘½';
    requestAnimationFrame(frame);
  }

  init();

})();
</script>
</body>
</html>
